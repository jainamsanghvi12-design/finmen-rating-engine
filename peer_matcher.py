
"""\nFINMEN Peer Matching Engine - Automatic peer discovery and analysis\nMatches similar companies based on industry, rating, and financial metrics\n"""\n\nimport pandas as pd\nimport numpy as np\nfrom typing import List, Dict, Tuple\nfrom difflib import SequenceMatcher\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n# Rating hierarchy for comparison\nRATING_HIERARCHY = {\n    'AAA': 1, 'AA+': 2, 'AA': 3, 'AA-': 4,\n    'A+': 5, 'A': 6, 'A-': 7,\n    'BBB+': 8, 'BBB': 9, 'BBB-': 10,\n    'BB+': 11, 'BB': 12, 'BB-': 13,\n    'B+': 14, 'B': 15, 'B-': 16,\n    'C': 17, 'D': 18, 'NR': 19\n}\n\nclass PeerMatcher:\n    """Intelligent peer matching engine for credit rating analysis"""\n    \n    def __init__(self, peer_database: pd.DataFrame = None):\n        """\n        Initialize peer matcher with company database\n        \n        Args:\n            peer_database: DataFrame with company data (name, industry, rating, etc.)\n        """\n        self.peer_database = peer_database or self._create_sample_database()\n        self.match_weights = {\n            'industry': 0.35,\n            'rating': 0.30,\n            'size': 0.15,\n            'outlook': 0.10,\n            'agency': 0.10\n        }\n    \n    def _create_sample_database(self) -> pd.DataFrame:\n        """Create sample database for testing"""\n        return pd.DataFrame({\n            'company_name': [\n                'Ashiana Housing', 'Lodha Group', 'Prestige Estates', 'Oberoi Realty',\n                'Kotak Bank', 'HDFC Bank', 'ICICI Bank', 'Axis Bank',\n                'Bajaj Finance', 'HDFC Ltd', 'Reliance Industries'\n            ],\n            'industry': [\n                'Real Estate', 'Real Estate', 'Real Estate', 'Real Estate',\n                'Banking', 'Banking', 'Banking', 'Banking',\n                'NBFC', 'NBFC', 'Energy'\n            ],\n            'rating': [\n                'A+', 'A+', 'A', 'AA-',\n                'AAA', 'AA+', 'AA+', 'AA',\n                'AAA', 'AA+', 'AAA'\n            ],\n            'agency': [\n                'ICRA', 'ICRA', 'CARE', 'CRISIL',\n                'CRISIL', 'ICRA', 'CARE', 'CRISIL',\n                'ICRA', 'CRISIL', 'CRISIL'\n            ],\n            'outlook': [\n                'Stable', 'Positive', 'Stable', 'Stable',\n                'Stable', 'Positive', 'Stable', 'Stable',\n                'Positive', 'Stable', 'Stable'\n            ]\n        })\n    \n    def find_peers(self, company_name: str, industry: str, rating: str, \n                   top_n: int = 5) -> List[Dict]:\n        """\n        Find top matching peers for a company\n        \n        Args:\n            company_name: Name of the company\n            industry: Industry sector\n            rating: Credit rating\n            top_n: Number of peers to return\n            \n        Returns:\n            List of matched peers with similarity scores\n        """\n        matches = []\n        \n        for idx, row in self.peer_database.iterrows():\n            if row['company_name'].lower() == company_name.lower():\n                continue  # Skip the company itself\n            \n            score = self._calculate_match_score(\n                industry, rating,\n                row['industry'], row['rating'], row['outlook']\n            )\n            \n            matches.append({\n                'company': row['company_name'],\n                'industry': row['industry'],\n                'rating': row['rating'],\n                'agency': row['agency'],\n                'outlook': row['outlook'],\n                'match_score': round(score, 2),\n                'match_percentage': round(score * 100, 1)\n            })\n        \n        # Sort by match score descending\n        matches.sort(key=lambda x: x['match_score'], reverse=True)\n        \n        return matches[:top_n]\n    \n    def _calculate_match_score(self, industry1: str, rating1: str, \n                               industry2: str, rating2: str, outlook2: str) -> float:\n        """Calculate similarity score between two companies"""\n        scores = {}\n        \n        # Industry match\n        industry_match = SequenceMatcher(None, industry1.lower(), industry2.lower()).ratio()\n        scores['industry'] = industry_match\n        \n        # Rating match (proximity in rating hierarchy)\n        rating_diff = abs(RATING_HIERARCHY.get(rating1, 10) - RATING_HIERARCHY.get(rating2, 10))\n        rating_match = max(0, 1 - (rating_diff * 0.05))  # Decay with distance\n        scores['rating'] = rating_match\n        \n        # Outlook bonus\n        scores['outlook'] = 0.5 if outlook2 == 'Positive' else 0.3\n        \n        # Calculate weighted score\n        weighted_score = sum(\n            scores.get(key, 0) * self.match_weights.get(key, 0)\n            for key in self.match_weights.keys()\n        )\n        \n        return min(1.0, weighted_score)\n    \n    def get_peer_analysis(self, company_name: str, industry: str, rating: str) -> Dict:\n        """\n        Get comprehensive peer analysis\n        \n        Args:\n            company_name: Company name\n            industry: Industry sector\n            rating: Credit rating\n            \n        Returns:\n            Dictionary with peer analysis and insights\n        """\n        peers = self.find_peers(company_name, industry, rating, top_n=10)\n        \n        return {\n            'target_company': company_name,\n            'industry': industry,\n            'rating': rating,\n            'peer_count': len(peers),\n            'top_peers': peers[:5],\n            'all_peers': peers,\n            'average_peer_rating': self._get_average_rating([p['rating'] for p in peers]),\n            'better_rated_peers': [p for p in peers if self._is_better_rating(rating, p['rating'])],\n            'worse_rated_peers': [p for p in peers if self._is_worse_rating(rating, p['rating'])]\n        }\n    \n    def _is_better_rating(self, rating1: str, rating2: str) -> bool:\n        """Check if rating2 is better than rating1"""\n        return RATING_HIERARCHY.get(rating2, 20) < RATING_HIERARCHY.get(rating1, 20)\n    \n    def _is_worse_rating(self, rating1: str, rating2: str) -> bool:\n        """Check if rating2 is worse than rating1"""\n        return RATING_HIERARCHY.get(rating2, 20) > RATING_HIERARCHY.get(rating1, 20)\n    \n    def _get_average_rating(self, ratings: List[str]) -> str:\n        """Get average rating from a list of ratings"""\n        if not ratings:\n            return 'N/A'\n        \n        avg_hierarchy = sum(RATING_HIERARCHY.get(r, 10) for r in ratings) / len(ratings)\n        \n        # Find closest rating\n        closest_rating = min(RATING_HIERARCHY.items(), \n                            key=lambda x: abs(x[1] - avg_hierarchy))[0]\n        \n        return closest_rating\n    \n    def flag_opportunities(self, company_name: str, rating: str, outlook: str,\n                          peers: List[Dict]) -> Dict:\n        """\n        Flag upgrade/downgrade and other opportunities\n        \n        Args:\n            company_name: Company name\n            rating: Current rating\n            outlook: Current outlook\n            peers: List of peer companies\n            \n        Returns:\n            Dictionary with opportunity flags\n        """\n        opportunities = {\n            'company': company_name,\n            'flags': [],\n            'upgrade_potential': False,\n            'downgrade_risk': False,\n            'signal_strength': 'Neutral'\n        }\n        \n        if not peers:\n            return opportunities\n        \n        # Count better/worse rated peers\n        better_peers = [p for p in peers if self._is_better_rating(rating, p['rating'])]\n        worse_peers = [p for p in peers if self._is_worse_rating(rating, p['rating'])]\n        \n        # Upgrade signals\n        if outlook == 'Positive' and len(better_peers) >= 2:\n            opportunities['flags'].append({\n                'type': 'UPGRADE_SIGNAL',\n                'description': f'Positive outlook with {len(better_peers)} better-rated peers',\n                'priority': 'HIGH'\n            })\n            opportunities['upgrade_potential'] = True\n            opportunities['signal_strength'] = 'STRONG'\n        \n        # Downgrade signals\n        if outlook == 'Negative' and len(worse_peers) >= 2:\n            opportunities['flags'].append({\n                'type': 'DOWNGRADE_SIGNAL',\n                'description': f'Negative outlook with {len(worse_peers)} worse-rated peers',\n                'priority': 'HIGH'\n            })\n            opportunities['downgrade_risk'] = True\n            opportunities['signal_strength'] = 'STRONG'\n        \n        # Peer gap analysis\n        if len(better_peers) > len(worse_peers) * 2:\n            opportunities['flags'].append({\n                'type': 'PEER_GAP',\n                'description': 'Company is lagging behind peers',\n                'priority': 'MEDIUM'\n            })\n        \n        return opportunities\n\n\n# Module-level functions for easy usage\nPEER_MATCHER = None\n\ndef initialize_peer_matcher(database: pd.DataFrame = None):\n    """Initialize the global peer matcher"""\n    global PEER_MATCHER\n    PEER_MATCHER = PeerMatcher(database)\n\ndef match_peers(company_name: str, industry: str, rating: str, top_n: int = 5):\n    """Find peers for a company"""\n    if PEER_MATCHER is None:\n        initialize_peer_matcher()\n    return PEER_MATCHER.find_peers(company_name, industry, rating, top_n)\n\ndef analyze_peers(company_name: str, industry: str, rating: str):\n    """Get comprehensive peer analysis"""\n    if PEER_MATCHER is None:\n        initialize_peer_matcher()\n    return PEER_MATCHER.get_peer_analysis(company_name, industry, rating)\n\ndef flag_opportunities(company_name: str, rating: str, outlook: str, peers: List[Dict]):\n    """Flag opportunities and signals"""\n    if PEER_MATCHER is None:\n        initialize_peer_matcher()\n    return PEER_MATCHER.flag_opportunities(company_name, rating, outlook, peers)\n
